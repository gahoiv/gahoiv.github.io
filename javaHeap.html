<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<!-- Metadata to edit -->
	<title> A practical introduction to git</title>
	<meta name="author" content="Anna Kennedy">
	<!-- /Metadata to edit -->

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="css/reveal.min.css">
	<link rel="stylesheet" href="css/heap.css">
	<link rel="stylesheet" href="css/theme/sky.css" id="theme">

	<!-- For syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- If the query includes 'print-pdf', include the PDF print sheet -->
	<script>
		if (window.location.search.match(/print-pdf/gi)) {
			var link = document.createElement('link');
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = 'css/print/pdf.css';
			document.getElementsByTagName('head')[0].appendChild(link);
		}
	</script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

	<div class="reveal">
		<div class="slides">

			<!-- Title slide -->
			<section>
				<h1>Java Heap</h1>
				<p>
					<small>Vishwas Gahoi</small>
				</p>
				<aside class="notes">
					Some notes here
				</aside>
			</section>
			<!-- Overview -->
			<section>
				<h1>Overview</h1>
				<p class="fragment">
					<ul>
						<li>Java Virtual Machine (JVM)</li>
						<li>Java Memory Models</li>
						<li>Heap and Non-Heap Memory</li>
						<li>Allocated and Used Memory</li>
						<li>Java Stack Memory</li>
						<li>Garbage Collection</li>
						<li>Mark and Sweep Model of Garbage collection</li>
						<li>Monitoring of Memory Use and GC Activity</li>
						<li>Java Garbage Collection Tuning</li>
						<li>Sources</li>
						<li>Related</li>
					</ul>
				</p>
				<aside class="notes">
				</aside>
			</section>
			<section>
				<h2>Java (JVM) Memory Structure</h2>
				<p>JVM memory is divided into multiple parts: Heap Memory, Non-Heap Memory, and Other.</p>
				<p class="fragment">
					<p>
						<img width="550" src="img/JVM-Memory-Model.jpg" alt="gitlab">
					</p>
				</p>
			</section>
			<section>
				<h3>Heap memory</h3>
				<p class="fragment">
					<ul>
						<li>Run time data area from which the memory for all java class instances</li>
						<li>The size of the heap can be specified using –Xms VM option.</li>
						<li>The heap can be of fixed size or variable size depending on the garbage collection strategy.</li>
						<li>Maximum heap size can be set using –Xmx option default value is 64MB</li>
					</ul>
				</p>
			</section>
			<section>
				<h3>Non Heap memory</h3>
				<p class="fragment">
					<ul>
						<li>It is created at the JVM startup and stores per-class structures such as runtime constant pool, field and method data,
							and the code for methods and constructors, as well as interned Strings.</li>
						<li>This can be changed using –XX:MaxPermSize VM option, default value is 64MB</li>
						<li>JVM uses other memory to store the JVM code itself, JVM internal structures, loaded profiler agent code and data, etc.</li>
					</ul>
				</p>
			</section>
			<section>
				<h3>Java (JVM) Heap Memory Structure</h3>
				<p class="fragment">
					<p>
						<center>
							<img width="550" src="img/java-memory-management-1.jpg">
						</center>
					</p>
					<ul class='small'>

						<li>The JVM heap is physically divided into two parts (or generations): nursery (or young space/young generation) and old
							space (or old generation).</li>
						<li>The nursery is a part of the heap reserved for allocation of new objects.</li>
						<li>When the nursery becomes full, garbage is collected by running a special young collection, where all the objects that
							have lived long enough in the nursery are promoted (moved) to the old space</li>
						<li>This garbage collection is called Minor GC. The nursery is divide into three parts – Eden Memory and two Survivor Memory
							spaces.
						</li>
					</ul>
				</p>
			</section>
			<section>
				<h3>cont...</h3>
				<p class="fragment">
					<ul>
						<li>Most of the newly created objects are located in the Eden Memory space.</li>
						<li>Minor GC also checks the survivor objects and moves them to the other survivor space. So at a time, one of the survivor
							space is always empty.</li>
						<li>Objects that have survived many cycles of GC, are moved to the old generation memory space. Usually it is done by setting
							a threshold for the age of the nursery objects before they become eligible to promote to old generation</li>
						<li>Old generation garbage collection is called as Major GC and usually takes longer time.
						</li>
					</ul>
				</p>
			</section>
			<section>
				<h3>Java Memory Models</h3>
				<h4>Permanent Generation</h4>
				<p class="fragment">
					<ul class='small'>
						<li>Perm Gen is populated by JVM at runtime based on the classes used by the application.</li>
						<li>Perm Gen also contains Java SE library classes and methods. Perm Gen objects are garbage collected in a full garbage
							collection.</li>
					</ul>
				</p>
				<h4>Metaspace</h4>
				<p class="fragment">
					<ul class='small'>
						<li>With Java 8, there is no Perm Gen, that means there is no more “java.lang.OutOfMemoryError: PermGen” space problems.</li>
						<li>Metaspace is not part of the heap.</li>
						<li>metadata are now allocated out of native memory. Metaspace by default auto increases its size</li>
						<li>“-XX:MetaspaceSize” and “-XX:MaxMetaspaceSize”.</li>
						<li>Metaspace is that the lifetime of classes and their metadata matches the lifetime of the classloaders.</li>
					</ul>
				</p>
			</section>
			<section>
				<h4>Object Allocation</h4>
				<p class="fragment">
					<ul class='small'>
						<li>During object allocation, the JVM distinguishes between small and large objects.</li>
						<li>The limit for when an object is considered large depends on the JVM version, the heap size, the garbage collection strategy and the platform used, but is usually somewhere between 2 and 128 kB.</li>
						<li>Small objects are allocated in thread local areas (TLAs). The thread local areas are free chunks reserved from the heap and given to a Java thread for exclusive use.</li>
						<li>The thread can then allocate objects in its TLA without synchronizing with other threads. When the TLA becomes full, the thread simply requests a new TLA.</li>
						<li>The TLAs are reserved from the nursery</li>
						<li>Large objects that don’t fit inside a TLA are allocated directly on the heap. When a nursery is used, the large objects are allocated directly in old space.</li>
					</ul>
				</p>
			</section>
			<section>
				<h4>Garbage Collection</h4>
				<h5>The Mark and Sweep Model</h5>
				<p class="fragment">
					<ul class='small'>
						<li>Mark and sweep garbage collection model for performing garbage collections of the whole heap.</li>
						<li title='where the root set of live objects is identified. This is done while the Java threads are paused.'>Initial marking</li>
						<li title='Where the references from the root set are followed in order to find and mark the rest of the live objects in the heap'>Concurrent marking,</li>
						<li title='Where changes in the heap during the concurrent mark phase are identified and any additional live objects are found and marked.'>Precleaning</li>
						<li>The parallel mark and sweep strategy (also called the parallel garbage collector) uses all available CPUs in the system for performing the garbage collection as fast as possible. All Java threads are paused during the entire parallel garbage collection.</li>
					</ul>
				</p>
				<h5>Generational Garbage Collection</h5>
			</section>
			<section>
				<h5>Dynamic and Static Garbage Collection Modes</h5>
				<p class="fragment">
					<ul class='small'>
						<li>JVM uses a dynamic garbage collection mode that automatically selects a garbage collection strategy to use, aiming at optimizing the application throughput. You can also choose between two other dynamic garbage collection modes or select the garbage collection strategy statically.</li>
						<li>The following dynamic modes are available:
							<ul>
								<li title='which optimizes the garbage collector for maximum application throughput.'>throughput</li>
								<li title='which optimizes the garbage collector for short and even pause times.'>pausetime</li>
								<li title='which optimizes the garbage collector for very short and deterministic pause times.'>deterministic</li>
							</ul>
						</li>
						<li>The major static strategies are:
							<ul>
								<li title='which is a single-generational parallel garbage collector.'>singlepar</li>
								<li title='which is a two-generational parallel garbage collector.'>genpar</li>
								<li title='which is a single-generational mostly concurrent garbage collector.'>singlecon</li>
								<li title='which is a two-generational mostly concurrent garbage collector'>gencon</li>
							</ul>
						</li>
					</ul>
				</p>
				
			</section>
			<section>
				<h5>Compaction</h5>
				<p class="fragment">
					<ul class='small'>
						<li>Objects that are allocated next to each other will not necessarily become unreachable (“die”) at the same time. This means that the heap may become fragmented after a garbage collection, so that the free spaces in the heap are many but small, making allocation of large objects hard or even impossible.</li>
						<li>Free spaces that are smaller than the minimum thread local area (TLA) size can not be used at all, and the garbage collector discards them as dark matter until a future garbage collection frees enough space next to them to create a space large enough for a TLA.</li>
						<li>Compaction moves objects closer together and further down in the heap, thus creating larger free areas near the top of the heap.</li>
						<li>External and Internal Compaction:
							<ul>
								<li>External compaction moves (evacuates) the objects within the compaction area to free positions outside the compaction area and as far down in the heap as possible.</li>
								<li>Internal compaction moves the objects within the compaction area as far down in the compaction area as possible, thus moving them closer together.</li>
								<li>The JVM selects a compaction method depending on the current garbage collection mode and the position of the compaction area.</li>
								<li>External compaction is typically used near the top of the heap, while internal compaction is used near the bottom where the density of objects is higher.</li>
							</ul>
						</li>
						<li>Sliding Window Schemes:
							<ul>
								<li title=' Each sliding window moves a notch up or down in the heap at each garbage collection, until it reaches the other end of the heap or meets a sliding window that moves in the opposite direction, and starts over again. Thus the whole heap is eventually traversed by compaction over and over again.'>The position of the compaction area changes at each garbage collection, using one or two sliding windows to determine the next position. .</li>
							</ul>
						</li>
						<li>Compaction Area Sizing:
							<ul>
								<li>The size of the compaction area depends on the garbage collection mode used..</li>
								<li>In throughput mode the compaction area size is static, while all other modes, including the static mode, adjust the compaction area size depending on the compaction area position.</li>
								<li title='Thus the compaction area will be smaller in parts of the heap where the object density is high or where the amount of references to the objects within the area is high. Typically the object density is higher near the bottom of the heap than at the top of the heap, except at the very top where the latest allocated objects are found. Thus the compaction areas are usually smaller near the bottom of the heap than in the top half of the heap.'>The compaction time depends on the number of objects moved and the number of references to these objects.</li>
							</ul>
						</li>
					</ul>
				</p>
				
			</section>
			<section>
				<h5>Java Stack Memory</h5>
				<p class="fragment">
					<ul class='small'>
						<li>Java Stack memory is used for execution of a thread.</li>
						<li> They contain method specific values that are short-lived and references to other objects in the heap that are getting referred from the method.</li>
						<li title='Whenever a method is invoked, a new block is created in the stack memory for the method to hold local primitive values and reference to other objects in the method. As soon as method ends, the block becomes unused and become available for next method.
						Stack memory size is very less compared to Heap memory.'>Stack memory is always referenced in LIFO (Last-In-First-Out) order.</li>
						<li>Java Runtime creates stack memory to be used by main() method thread.</li>
						<li>local variable created and stored in the stack memory of main() method.</li>
						<li>Object is created in Heap memory and stack memory contains the reference for it. </li>
						<li>A string goes in the String Pool in the heap space and a reference is created in the foo() stack space for it.</li>
						<li>Heap memory is used by all the parts of the application whereas stack memory is used only by one thread of execution.</li>
						<li>Objects stored in the heap are globally accessible whereas stack memory can’t be accessed by other threads.</li>
						<li>We can use -Xss to define the stack memory size.</li>
						<li>Stack memory is very fast when compared to heap memory.</li>
					</ul>
				</p>
				
			</section>
			<section>
				<h5>String Pool</h5>
				<p class="fragment">
					<ul class='small'>
						<li>String Pool in java is a pool of Strings stored in Java Heap Memory.</li>
						<li title='When we use double quotes to create a String, it first looks for String with same value in the String pool, if found it just returns the reference else it creates a new String in the pool and then returns the reference'>String pool helps in saving a lot of space for Java Runtime although it takes more time to create the String.</li>
						<li title='Interning strings makes some string processing tasks more time- or space-efficient at the cost of requiring more time when the string is created or interned. The distinct values are stored in a string intern pool.'>string interning is a method of storing only one copy of each distinct string value, which must be immutable.</li>
					</ul>
				</p>
				
			</section>

		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.min.js"></script>

	<script>

		// Full list of configuration options available here:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
			transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

			// Parallax scrolling
			// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
			// parallaxBackgroundSize: '2100px 900px',

			// Optional libraries used to extend on reveal.js
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function () { return !!document.body.classList; } },
				{ src: 'plugin/notes/notes.js', async: true, condition: function () { return !!document.body.classList; } }
			]
		});

	</script>

</body>

</html>